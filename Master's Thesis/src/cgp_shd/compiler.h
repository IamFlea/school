//=======================================================================================
//This file was generated by CGP generator (http://www.fit.vutbr.cz/~vasicek/cgp) 
//=======================================================================================

#if !(defined __LP64__ || defined __LLP64__) || defined _WIN32 && !defined _WIN64
 #error "32-bit architecture is not supported"
#else
 // we are compiling for a 64-bit system
#endif

unsigned char* consts;
void cgp_init_consts()
{
    #define B(val)  *(pconst++)=(val)
    unsigned char* pconst;
    pconst = consts = malloc_aligned(10);
    ///Initialize constants
    B(0x34); B(0x12); B(0x00); B(0x00); B(0x56); B(0x13); B(0x00); B(0x00); B(0xe2); B(0x1f); 
}

#define MAXCODESIZE 24
unsigned char* code[MAX_POPSIZE];
#ifdef COMPILE_FITNESS
typedef int evalfunc(void);
void cgp_compile(unsigned char* pcode, chromosome p_chrom, int* isused, long int** inputdata)
#else
typedef void evalfunc(void);
void cgp_compile(unsigned char* pcode, chromosome p_chrom, int* isused)
#endif
{
    #define C(val)  *(pcode++)=(val)
    #define CI(val) {*((uint32_t *)(pcode))= (uint32_t)((__PTRDIFF_TYPE__)val); pcode += sizeof(uint32_t);}
    #define CL(val) {*((uint64_t *)(pcode))= (uint64_t)((__PTRDIFF_TYPE__)val); pcode += sizeof(uint64_t);}

    int pnodeout = 0;
    int in1,in2,fce;
    int out = params.inputs - 1;

    /// Save modified registers
    /// %rbx, %rax
    C(0x53);                                          //push   %rbx
    /// Load pointer to node outputs array into ebx
    C(0x48);C(0xbb);CL(nodeoutput);

#ifdef COMPILE_FITNESS
    C(0x56);                                          //push   %rsi
    /// Load *inputdata to rsi
    C(0x48);C(0xb8);CL(inputdata);
    C(0x48);C(0x8b);C(0x30);
#endif
    /// Native code generation
    for (int i=0; i < params.cols; i++)
        for (int j=0; j < params.rows; j++) 
        { 
            in1 = *p_chrom++; in2 = *p_chrom++; fce = *p_chrom++; out++;
            #ifdef DONOTEVALUATEUNUSEDNODES
            if (!isused[out]) continue;
            #endif
            switch (fce)
            {
              case 0:
                  ///nodeoutput[out] = nodeoutput[in1];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 14, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 1:
                  ///nodeoutput[out] = ~nodeoutput[in1];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 17, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 2:
                  ///nodeoutput[out] = nodeoutput[in1] & nodeoutput[in2];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x23);C(0x83);CI(8*in2);                //and    in2(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 21, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 3:
                  ///nodeoutput[out] = nodeoutput[in1] | nodeoutput[in2];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x0b);C(0x83);CI(8*in2);                //or     in2(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 21, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 4:
                  ///nodeoutput[out] = nodeoutput[in1] ^ nodeoutput[in2];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x33);C(0x83);CI(8*in2);                //xor    in2(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 21, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 5:
                  ///nodeoutput[out] = ~(nodeoutput[in1] & nodeoutput[in2]);
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x23);C(0x83);CI(8*in2);                //and    in2(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 24, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 6:
                  ///nodeoutput[out] = ~(nodeoutput[in1] | nodeoutput[in2]);
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x0b);C(0x83);CI(8*in2);                //or     in2(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 24, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 7:
                  ///nodeoutput[out] = ~(nodeoutput[in1] ^ nodeoutput[in2]);
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x33);C(0x83);CI(8*in2);                //xor    in2(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 24, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              default:
                  abort();
              }
        } 
#ifdef COMPILE_FITNESS
    // FITNESS CALCULATION 
    // ===================
    // Store used register
    C(0x52);                                              //push   %rdx
    C(0x48);C(0x31);C(0xd2);                              //xor    %rdx,%rdx       ; rdx is used for fitness value
    // Foreach output calculate weighted fitness.
    for (int i=0; i < params.outputs; i++)
    {
        in1 = *p_chrom++;
        C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax    ; get obtained data..
        C(0x48);C(0x33);C(0x06);                          //xor    %rax, [%rsi]      ; ..xor them with reference data
        //C(0x48);C(0xf7);C(0xd0);                          //not    %rax              ; flip ones and zeros  shd=(64-popcnt[rax])
        C(0xF3);C(0x48);C(0x0F);C(0xB8);C(0xC0);          //popcnt %rax,%rax         ; how many ones are used?
        C(0x48);C(0x83);C(0xc6);C(0x08);                  //add    %rsi, $8          ; move pointer to next reference value
        C(0x48);C(0x01);C(0xc2);                          //add    %rdx,%rax         ; calculate sum
    }
    C(0x48);C(0x89);C(0xd0);                              //mov    %rdx,%rax        
    /// Restore modified registers
    C(0x5a);                                              //pop    %rdx
    C(0x5e);                                              //pop    %rsi ; haha poprsi
#endif
    /// Restore modified registers
    C(0x5b);                                          //pop    %rbx
    /// Return
    C(0xc3);
}
